<!DOCTYPE html><html class="default" lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>Documentation</title><meta name="description" content="Documentation for Documentation"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script defer src="assets/main.js"></script><script async src="assets/search.js" id="tsd-search-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os"</script><header class="tsd-page-toolbar">
<div class="tsd-toolbar-contents container">
<div class="table-cell" id="tsd-search" data-base=".">
<div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M15.7824 13.833L12.6666 10.7177C12.5259 10.5771 12.3353 10.499 12.1353 10.499H11.6259C12.4884 9.39596 13.001 8.00859 13.001 6.49937C13.001 2.90909 10.0914 0 6.50048 0C2.90959 0 0 2.90909 0 6.49937C0 10.0896 2.90959 12.9987 6.50048 12.9987C8.00996 12.9987 9.39756 12.4863 10.5008 11.6239V12.1332C10.5008 12.3332 10.5789 12.5238 10.7195 12.6644L13.8354 15.7797C14.1292 16.0734 14.6042 16.0734 14.8948 15.7797L15.7793 14.8954C16.0731 14.6017 16.0731 14.1267 15.7824 13.833ZM6.50048 10.499C4.29094 10.499 2.50018 8.71165 2.50018 6.49937C2.50018 4.29021 4.28781 2.49976 6.50048 2.49976C8.71001 2.49976 10.5008 4.28708 10.5008 6.49937C10.5008 8.70852 8.71314 10.499 6.50048 10.499Z" fill="var(--color-text)"></path></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div>
<div class="field">
<div id="tsd-toolbar-links"></div></div>
<ul class="results">
<li class="state loading">Preparing search index...</li>
<li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">Documentation</a></div>
<div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="1" y="3" width="14" height="2" fill="var(--color-text)"></rect><rect x="1" y="7" width="14" height="2" fill="var(--color-text)"></rect><rect x="1" y="11" width="14" height="2" fill="var(--color-text)"></rect></svg></a></div></div></header>
<div class="container container-main">
<div class="col-content">
<div class="tsd-page-title">
<h2>Documentation</h2></div>
<div class="tsd-panel tsd-typography"><a id="md:redis-work-queue" class="tsd-anchor"></a><h1><a href="#md:redis-work-queue">Redis Work Queue</a></h1><p>A work queue, on top of a redis database, with implementations in Python, Rust, Go, C# and TypeScript.</p>
<p>This provides no method of tracking the outcome of work items. This is fairly simple to implement
yourself (just store the result in the redis database with a key derived from the work item id). If
you want a more fully-featured system for managing jobs, see our <a href="https://github.com/MeVitae/redis-collection-manager">Collection
Manager</a>.</p>
<p>Implementations in other languages are welcome, open a PR!</p>
<a id="md:documentation" class="tsd-anchor"></a><h2><a href="#md:documentation">Documentation</a></h2><p>In addition to the primary overview below, each implementation has its own examples and API
reference.</p>
<ul>
<li><p>Python: <a href="https://pypi.org/project/redis-work-queue/"><img src="https://img.shields.io/pypi/v/redis-work-queue" alt="PyPI"></a>
<a href="./python/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT License"></a></p>
</li>
<li><p>Rust: <a href="https://crates.io/crates/redis-work-queue"><img src="https://img.shields.io/crates/v/redis-work-queue" alt="Crates.io"></a>
<a href="https://docs.rs/redis-work-queue"><img src="https://img.shields.io/docsrs/redis-work-queue" alt="docs.rs"></a>
<a href="./LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT License"></a></p>
</li>
<li><p>Go: <a href="https://goreportcard.com/report/github.com/mevitae/redis-work-queue/go"><img src="https://goreportcard.com/badge/github.com/mevitae/redis-work-queue/go" alt="Go Report Card"></a>
<a href="https://pkg.go.dev/github.com/mevitae/redis-work-queue/go"><img src="https://pkg.go.dev/badge/github.com/mevitae-redis-work-queue/go" alt="GoDoc"></a>
<a href="./LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT License"></a></p>
</li>
<li><p>TypeScript: <a href="Reportcardurl">![TypeScript Report Card] (Reportcard) )</a>
<a href="docs"><img src="badge" alt="npm"></a>
<a href="./LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT License"></a></p>
</li>
</ul>
<a id="md:overview" class="tsd-anchor"></a><h2><a href="#md:overview">Overview</a></h2><p>All the implementations share the same operations, on the same core types, these are:</p>
<a id="md:items" class="tsd-anchor"></a><h3><a href="#md:items">Items</a></h3><p>Items in the work queue consist of an <code>id</code>, a string, and some <code>data</code>, arbitrary bytes.</p>
<p>For convenience, the IDs are often randomly generated UUIDs, however they can be customized.
Another item with the same ID as a previous item shouldn&#39;t be added until the previous item has been
completed.</p>
<a id="md:adding-an-item" class="tsd-anchor"></a><h3><a href="#md:adding-an-item">Adding an item</a></h3><p><em>Python: <code>WorkQueue.add_item</code>,
Rust: <a href="https://docs.rs/redis-work-queue/latest/redis_work_queue/struct.WorkQueue.html#method.add_item"><code>WorkQueue::add_item</code></a>,
TypeScript: <a href="WorkQueue-addItem"><code>WorkQueue::add_item</code></a>,
Go: <a href="https://pkg.go.dev/github.com/mevitae/redis-work-queue/go#WorkQueue.AddItem"><code>WorkQueue.AddItem</code></a></em></p>
<p>Adding an item is exactly what it sounds like! It adds an item to the work queue. It will then
either be in the queue or being processed (before coming back to the queue if the processing fails)
until the job is completed.</p>
<a id="md:leasing-an-item" class="tsd-anchor"></a><h3><a href="#md:leasing-an-item">Leasing an item</a></h3><p><em>Python: <code>WorkQueue.lease</code>,
Rust: <a href="https://docs.rs/redis-work-queue/latest/redis_work_queue/struct.WorkQueue.html#method.lease"><code>WorkQueue::lease</code></a>,
TypeScript: <a href="WorkQueue-lease"><code>WorkQueue::lease</code></a>,
Go: <a href="https://pkg.go.dev/github.com/mevitae/redis-work-queue/go#WorkQueue.Lease"><code>WorkQueue.Lease</code></a></em></p>
<p>Workers wanting to receive a job and complete it must start by obtaining a lease.</p>
<p>When requesting a lease, you exchange an expiry time for an item. The worker should then complete
the item before the expiry time by calling <code>complete</code>. If <code>complete</code> isn&#39;t called in time, it&#39;s
assumed that the worker died and the item is returned to the queue for another worker to pick up.</p>
<p>This means that a worker can receive a job that another worker has already partially or fully
completed (and then died before calling <code>complete</code>) or even for two workers to be simultaneously
working on the same job if the lease expiry was too short (try to avoid this if possible!). It&#39;s
therefore important that workers are written in a way that won&#39;t cause problems if a worker starts
again after another worker has already fully or partially completed the task, or is working on it at
the same time. This allows a fully resilient system.</p>
<p>The work queue cannot loose track of a job once it&#39;s been added, so, as long as workers keep
successfully working, a job will always be run to completion (even if it is run multiple times in
that process).</p>
<p>If you&#39;re unhappy about jobs being run more than once, see <a href="#">But I never want my job to run more than
once</a>.</p>
<a id="md:storing-the-result-of-a-work-item" class="tsd-anchor"></a><h4><a href="#md:storing-the-result-of-a-work-item">Storing the result of a work item</a></h4><p>The work queue provides no method of tracking the outcome of work items. This is fairly simple to
implement yourself (just store the result in the redis database with a key derived from the work
item id). If you want a more fully-featured system for managing jobs, see our <a href="https://github.com/MeVitae/redis-collection-manager">Collection
Manager</a>.</p>
<a id="md:handling-errors" class="tsd-anchor"></a><h4><a href="#md:handling-errors">Handling errors</a></h4><p>If an error occurs and the job should be retried, later on, by the same or different worker, then
the worker should <strong>not</strong> call <code>complete</code> and should obtain another lease and work on the next item,
ignoring the one it was previously processing. When the previous lease expires, it will be returned
to the work queue and will be retried. For example:</p>
<pre><code class="language-python"><span class="hl-0">while</span><span class="hl-1"> </span><span class="hl-2">True</span><span class="hl-1">:</span><br/><span class="hl-1">    job = work_queue.lease(</span><span class="hl-3">100</span><span class="hl-1">)</span><br/><span class="hl-1">    </span><span class="hl-4"># ... do some work ...</span><br/><span class="hl-1">    </span><span class="hl-0">if</span><span class="hl-1"> should_try_again_later:</span><br/><span class="hl-1">        </span><span class="hl-4"># Don&#39;t call complete, just get another lease</span><br/><span class="hl-1">        </span><span class="hl-0">continue</span><br/><span class="hl-1">    </span><span class="hl-4"># ... finish the work ...</span><br/><span class="hl-1">    work_queue.complete(job)</span>
</code><button>Copy</button></pre>
<p>If an error occurs that means the job shouldn&#39;t be retried, you should send this error to the
correct place (perhaps the same place you put your results) and then call <code>complete</code>. The job then
won&#39;t be run again.</p>
<a id="md:but-i-never-want-my-job-to-run-more-than-once" class="tsd-anchor"></a><h4><a href="#md:but-i-never-want-my-job-to-run-more-than-once">But I never want my job to run more than once</a></h4><p>Before following the instructions below, you should think really hard about the title statement. If
the job can&#39;t run more than once then, and the worker dies during the work, the work will be left
incomplete, forever... <em>and ever...</em> <small><em>and ever...</em></small> (unless you have your own error
recovery system)</p>
<p>It&#39;s possible to write almost all jobs in a way which allows it to be restarted if a worker node
dies. If you can it&#39;s probably worth the effort!</p>
<a id="md:i-still-think-i-want-my-job-to-only-ever-possibly-run-once" class="tsd-anchor"></a><h5><a href="#md:i-still-think-i-want-my-job-to-only-ever-possibly-run-once">I still think I want my job to only ever possibly run once</a></h5><p>If this is the case, you should call <code>complete</code> (<strong>and check the return value</strong>) immediately
after obtaining the lease.</p>
<p>For example, in Python:</p>
<pre><code class="language-python"><span class="hl-1">job = queue.lease(</span><span class="hl-3">1000</span><span class="hl-1">)</span><br/><span class="hl-0">if</span><span class="hl-1"> queue.complete(job):</span><br/><span class="hl-1">    </span><span class="hl-4"># This will only run once, per job, ever, even if the worker dies</span><br/><span class="hl-1">    foo(job)</span>
</code><button>Copy</button></pre>
<p>This works because <code>complete</code> returns <code>true</code> <em>iff</em> it is the worker that completed the job. So while
<code>lease</code> may return the same job many times, <code>complete(job)</code> will return <code>true</code> only once per job.</p>
<a id="md:completing-an-item" class="tsd-anchor"></a><h3><a href="#md:completing-an-item">Completing an item</a></h3><p><em>Python: <a href="#"><code>WorkQueue.complete</code></a>,TypeScript: <a href="#"><code>WorkQueue.Complete</code></a>, Rust: <a href="#"><code>WorkQueue::complete</code></a>, Go: <a href="#"><code>WorkQueue.Complete</code></a></em></p>
<p>Complete marks a job as completed and remove it from the work queue. After <code>complete</code> has been called
(and returns <code>true</code>), no workers will receive this job again.</p>
<p><code>complete</code> returns a boolean indicating if <em>the job has been removed</em> <strong>and</strong> <em>this worker was the
first worker to call <code>complete</code></em>. So, while lease might give the same job to multiple workers,
complete will return <code>true</code> for only one worker.</p>
<a id="md:storing-the-result" class="tsd-anchor"></a><h4><a href="#md:storing-the-result">Storing the result</a></h4><p>See <a href="#">Storing the result of a work item</a></p>
<a id="md:cleaning" class="tsd-anchor"></a><h3><a href="#md:cleaning">Cleaning</a></h3><a id="md:light-cleaning" class="tsd-anchor"></a><h4><a href="#md:light-cleaning">Light cleaning</a></h4><p><em>Python: <code>WorkQueue.light_clean</code>, Rust implementation planned, no Go or C# implementation planned</em></p>
<p>When a worker dies while processing a job, or abandons a job, the job is left in the processing
state until it expires. The role of <em>light cleaning</em> is to move these jobs back to the main work
queue so another worker can pick them up.</p>
<p>The interval <em>light cleaning</em> should be run on should be approximately equal to the shortest lease
time you use.</p>
<a id="md:deep-cleaning" class="tsd-anchor"></a><h4><a href="#md:deep-cleaning">Deep cleaning</a></h4><p><em>Python and Rust implementations planned, no Go or C# implementation planned</em></p>
<p>In addition to this, a worker dying in the middle of a call to <code>complete</code> can leave database items
that are no longer associated with an active job. The job of a <em>deep clean</em> is to iterate over these
keys and make sure the database is clean.</p>
<p>It&#39;s very rare that deep cleaning is needed, but it can happen if you get really unlucky, so it
should be run automatically but infrequently.</p>
<p>The cleaning process we provide runs this every 6 hours by default.</p>
<a id="md:cleaning-process" class="tsd-anchor"></a><h4><a href="#md:cleaning-process">Cleaning process</a></h4><p>When there are many workers of different types, it&#39;s simpler just to have a dedicated process
running the cleaning. We provide a simple cleaner, both in Python and Rust.</p>
<a id="md:other-operations" class="tsd-anchor"></a><h3><a href="#md:other-operations">Other operations</a></h3><a id="md:getting-the-queue-length" class="tsd-anchor"></a><h4><a href="#md:getting-the-queue-length">Getting the queue length</a></h4><p><em>Python: <code>WorkQueue.queue_len</code>,
Rust: <a href="https://docs.rs/redis-work-queue/latest/redis_work_queue/struct.WorkQueue.html#method.queue_len"><code>WorkQueue::queue_len</code></a>,
Go: <a href="https://pkg.go.dev/github.com/mevitae/redis-work-queue/go#WorkQueue.QueueLen"><code>WorkQueue.QueueLen</code></a>,
TypeScript: <a href="WorkQueue.queueLen-link"><code>WorkQueue.queueLen</code></a></em></p>
<a id="md:getting-the-number-of-leased-items" class="tsd-anchor"></a><h4><a href="#md:getting-the-number-of-leased-items">Getting the number of leased items</a></h4><p><em>Python: <code>WorkQueue.processing</code>,
Rust: <a href="https://docs.rs/redis-work-queue/latest/redis_work_queue/struct.WorkQueue.html#method.processing"><code>WorkQueue::processing</code></a>,
TypeScript: <a href="WorkQueue.processing"><code>WorkQueue.processing</code></a>,
Go: <a href="https://pkg.go.dev/github.com/mevitae/redis-work-queue/go#WorkQueue.Processing"><code>WorkQueue.QueueLen</code></a></em></p>
<p>This includes items being worked on and abandoned items (see <a href="#handling-errors">Handling errors</a>) yet to be
returned to the main queue.</p>
<a id="md:testing" class="tsd-anchor"></a><h2><a href="#md:testing">Testing</a></h2><p>The client implementations each have their own (very simple) unit tests. Most of the testing is done
through the integrations tests, located in the <a href="./tests/">tests</a> directory.</p>
</div></div>
<div class="col-sidebar">
<div class="page-menu">
<div class="tsd-navigation settings">
<details class="tsd-index-accordion"><summary class="tsd-accordion-summary">
<h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4.93896 8.531L12 15.591L19.061 8.531L16.939 6.409L12 11.349L7.06098 6.409L4.93896 8.531Z" fill="var(--color-text)" id="icon-chevronDown"></path></svg>Settings</h3></summary>
<div class="tsd-accordion-details">
<div class="tsd-filter-visibility">
<h4 class="uppercase">Member Visibility</h4><form>
<ul id="tsd-filter-options">
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-private" name="private"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Private</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li></ul></form></div>
<div class="tsd-theme-toggle">
<h4 class="uppercase">Theme</h4><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div>
<details open class="tsd-index-accordion tsd-page-navigation"><summary class="tsd-accordion-summary">
<h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="#icon-chevronDown"></use></svg>On This Page</h3></summary>
<div class="tsd-accordion-details">
<ul>
<li>
<ul>
<li><a href="#md:redis-work-queue"><span>Redis <wbr/>Work <wbr/>Queue</span></a></li>
<li>
<ul>
<li><a href="#md:documentation"><span>Documentation</span></a></li>
<li><a href="#md:overview"><span>Overview</span></a></li>
<li>
<ul>
<li><a href="#md:items"><span>Items</span></a></li>
<li><a href="#md:adding-an-item"><span>Adding an item</span></a></li>
<li><a href="#md:leasing-an-item"><span>Leasing an item</span></a></li>
<li>
<ul>
<li><a href="#md:storing-the-result-of-a-work-item"><span>Storing the result of a work item</span></a></li>
<li><a href="#md:handling-errors"><span>Handling errors</span></a></li>
<li><a href="#md:but-i-never-want-my-job-to-run-more-than-once"><span>But <wbr/>I never want my job to run more than once</span></a></li>
<li>
<ul>
<li><a href="#md:i-still-think-i-want-my-job-to-only-ever-possibly-run-once"><span>I still think <wbr/>I want my job to only ever possibly run once</span></a></li></ul></li></ul></li>
<li><a href="#md:completing-an-item"><span>Completing an item</span></a></li>
<li>
<ul>
<li><a href="#md:storing-the-result"><span>Storing the result</span></a></li></ul></li>
<li><a href="#md:cleaning"><span>Cleaning</span></a></li>
<li>
<ul>
<li><a href="#md:light-cleaning"><span>Light cleaning</span></a></li>
<li><a href="#md:deep-cleaning"><span>Deep cleaning</span></a></li>
<li><a href="#md:cleaning-process"><span>Cleaning process</span></a></li></ul></li>
<li><a href="#md:other-operations"><span>Other operations</span></a></li>
<li>
<ul>
<li><a href="#md:getting-the-queue-length"><span>Getting the queue length</span></a></li>
<li><a href="#md:getting-the-number-of-leased-items"><span>Getting the number of leased items</span></a></li></ul></li></ul></li>
<li><a href="#md:testing"><span>Testing</span></a></li></ul></li></ul></li></ul></div></details></div>
<div class="site-menu">
<nav class="tsd-navigation"><a href="index.html" class="current"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><g id="icon-4"><rect fill="var(--color-icon-background)" stroke="var(--color-ts-namespace)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6"></rect><path d="M9.33 16V7.24H10.77L13.446 14.74C13.43 14.54 13.41 14.296 13.386 14.008C13.37 13.712 13.354 13.404 13.338 13.084C13.33 12.756 13.326 12.448 13.326 12.16V7.24H14.37V16H12.93L10.266 8.5C10.282 8.692 10.298 8.936 10.314 9.232C10.33 9.52 10.342 9.828 10.35 10.156C10.366 10.476 10.374 10.784 10.374 11.08V16H9.33Z" fill="var(--color-text)"></path></g></svg><span>Documentation</span></a>
<ul class="tsd-small-nested-navigation">
<li><a href="modules/Item.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-4"></use></svg><span>Item</span></a></li>
<li><a href="modules/KeyPrefix.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-4"></use></svg><span>Key<wbr/>Prefix</span></a></li>
<li><a href="modules/WorkQueue.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-4"></use></svg><span>Work<wbr/>Queue</span></a></li></ul></nav></div></div></div>
<div class="tsd-generator">
<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div>
<div class="overlay"></div></body></html>